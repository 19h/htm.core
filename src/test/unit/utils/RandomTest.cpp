/* ---------------------------------------------------------------------
 * Numenta Platform for Intelligent Computing (NuPIC)
 * Copyright (C) 2013, Numenta, Inc.  Unless you have an agreement
 * with Numenta, Inc., for a separate license for this software code, the
 * following terms and conditions apply:
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero Public License for more details.
 *
 * You should have received a copy of the GNU Affero Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 *
 * http://numenta.org/licenses/
 * ---------------------------------------------------------------------
 */

/**
 * @file
 */

#include <fstream>
#include <gtest/gtest.h>
#include <nupic/ntypes/MemStream.hpp>
#include <nupic/os/Env.hpp>
#include <nupic/utils/LoggingException.hpp>
#include <nupic/utils/Random.hpp>
#include <sstream>
#include <vector>

using namespace nupic;
using namespace std;

TEST(RandomTest, Seeding) {
  {
  Random r;
  auto x = r.getUInt32();
  ASSERT_TRUE(x != 0);
  }

  // test getSeed
  {
    Random r(98765);
    ASSERT_EQ(98765U, r.getSeed());
  }

  { // seed & equals
  Random r1(1); 
  Random r2(2);
  ASSERT_NE(r1.getUInt32(), r2.getUInt32());
  ASSERT_NE(r1, r2) << "Randoms with different seed must be different";

  Random r1b(1);
  ASSERT_NE(r1, r1b) << "different steps";
  auto x = r1b.getUInt32();
  ASSERT_EQ(r1, r1b) << "Randoms with same seed must be the same." << x; 
  }

}


TEST(RandomTest, CopyConstructor) {
  // test copy constructor.
  Random r1(289436);
  for (int i = 0; i < 100; i++)
    r1.getUInt32();
  Random r2(r1); //copy

  UInt32 v1, v2;
  for (int i = 0; i < 100; i++) {
    v1 = r1.getUInt32();
    v2 = r2.getUInt32();
    ASSERT_EQ(v1, v2) << "copy constructor";
  }
}


TEST(RandomTest, OperatorEquals) {
  // test operator=
  Random r1(289436);
  for (int i = 0; i < 100; i++)
    r1.getUInt32();
  Random r2(86726008);
  for (int i = 0; i < 100; i++)
    r2.getUInt32();

  r2 = r1;
  UInt32 v1, v2;
  for (int i = 0; i < 100; i++) {
    v1 = r1.getUInt32();
    v2 = r2.getUInt32();
    ASSERT_EQ(v1, v2) << "operator=";
  }
}

TEST(RandomTest, SerializationDeserialization) {
  // test serialization/deserialization
  Random r1(862973);
  for (int i = 0; i < 100; i++)
    r1.getUInt32();

  // serialize
  OMemStream ostream;
  ostream << r1;

  // print out serialization for debugging
  std::string x(ostream.str(), ostream.pcount());
//  NTA_INFO << "random serialize string: '" << x << "'";
  // Serialization should be deterministic and platform independent
  const std::string expectedString = "random-v2 862973 18278996500901106032 15671709857590179817 8649143637613862617 14264429998139648216 7771264048295431516 12226518405605705467 9772830111674237957 2323109042872219490 1972267838377633676 4143805970759863142 4624774728382164762 12935978031408885367 6972487223327110659 15846938151234461964 11219293672540080171 14696237751206470269 6237251308076371808 18303454838236991452 14830048466723621352 13323371025612656614 1037858307069662128 16624817170464937049 8537662857527322758 7385864444757712918 17956570412639773486 4855053662616968764 3655495107089919144 6157688543085567507 13640860710510529999 13745496315366170980 18190758010941307027 10888058020215811933 15457426345680933739 13222266253960919258 14000531053380469081 6445962488720243440 6759827609280687257 9685298126530559754 11839328416613730208 6900349664257781977 10412050736607118977 9124061408639164216 1823310794874452157 7096362482785184925 1021293691771630067 13476089715767250826 15728463420046675209 13565809498496819777 9240971383622733872 11786532890618023851 4466092817536822683 12138060308925662376 9779492982347927329 2296651319953831363 6486918918849116870 6589002633859405289 14867336130489681166 1192548725840495690 13141752414421483991 11134645008815067354 14583602513622966895 15960947115193958410 18353069494231827305 3351756852925883741 13485064114979771020 6339190459929307581 6092493536042535648 12775490997039948508 16938918407794598942 12425986851697247133 10077604765558312825 3841293312798158517 18226409647793166463 15053767120575981552 10123661549063671344 5451779945311442643 8601932045316207235 12925933527899203565 521567204405744150 11238568895268365923 10963397621656504303 1961818930936664622 9627734219248346861 4937607601245600553 13901192365207114619 3386902976004297107 2673374161914925356 5311167795143569620 6568893266240336821 2655161243531266295 5612167271838000560 13735243134516592904 4533745535730853329 5448929406991236112 14788774535855437970 14077606640909812000 5912648644150041866 7397160262012255201 12203995080258673397 7086710291991524617 18068923821240152691 11617645084918574301 3329015836024472831 4750448713647126429 12672508906530021165 13559104084492292096 1577478886855312205 5445593580097745559 5241014873998135932 6809582639954126746 12146628204439728391 6347410113983010931 4484239761900545258 2344706167516049994 10633130995961744046 2481454355401363631 1027371674501805941 11042740960021817330 2180515875846820979 2686316371058090993 6460108757191978129 11428255416650003160 1032255042732803172 9134069054302974144 10207956204260944197 11652197594967249178 16314103346691746127 12219728684028921059 2659434015512574443 7962968320374692538 10454351847394346376 9575019991700933390 4163964851284949654 6837582126540524893 16287742693491758850 5698534069126207329 8674356181128846427 6041854520491811047 14922093730153036266 14651125709342308795 865270013954178319 2464469368795060466 9515299453954011486 9904175940778356811 8684237949091436560 14641265258263876797 11194007137179012099 14607180489197747573 8716538491530480493 1995915804673391617 5797631934988564357 8259972137289137075 2787555451068468396 1312786590030608818 2628654432258593333 6020174472748330373 3924992758398899568 13660892272916950526 14592343489533950058 11629562707738206359 877184951808404161 11984873935423627025 12485568272296960015 17388610391211746396 14299035841800892309 9487901976514028950 9558989529141027192 10421458983121991348 14578987201341601905 2697551916353073944 2093006244159606540 3415819640709931227 15574273391924406448 1652897107963863536 159561568570104266 5884301525680715903 10185106882991485009 10785392918505111223 1174927153603916917 13482484179862035845 12406172019294686654 38969327760228580 4764185743914090431 651696507396561705 2077852583962748328 4785438127163514779 13102841800288845676 4889908843365015342 6669624380153822450 25974141135159446 5888513430134971856 7608760962656987312 17687280854384181456 16364916102675559332 9566134384197176110 15779916726996258782 9298908011080331086 3745889474208650401 11548862675781046300 14002498090823963862 14087913786702688017 15453582353246649517 12329476228190886563 3956676840709129590 9571200147725827891 17217472948481920618 9881170942923176486 10401220325915702660 8154957476331859609 12242491706491238678 4686095853942588746 2171661981660433114 8919955030613661062 17891525274857953346 12576832254897120856 9783219616832828757 3608296164371740644 2411003170075841417 17865025775570954703 2896991860734409921 5038941393951403874 4401839680434628288 11990859466063097394 11011664522716686867 729091238439240529 405464414201218881 2105250740906867538 14316580569859555091 4530109736278223294 7735650894519687432 2159639240650283689 11926873877772625117 12984655867977120392 5625588315509063670 9834755213541076480 2648172552609894741 10779660933474245039 68694957598655385 17536418038029877729 15025345101696676842 4826191464454688840 10385672626836887067 18309707544522964892 16688836695277258888 15668185175402533399 2135033745817588317 3620472290618138769 7844983645648051795 16579044331202905803 4429517479599118103 16831442372416762333 4890548298637904702 6545819644898104970 12201403701441111754 13538794021453860549 2779877820474353940 10094184035498551152 7856904176185743941 13718516137743924040 7006617972029757077 1440336980799782958 11318739778840911269 8629079412510769827 9848523213047448419 16054080765990091528 4417862554603522155 11011963754153905534 5466764592503369912 9773811298627394614 6176149347085553889 7480422445734772014 6367834212987818111 2755765288872895450 15037281496215311085 7247057054276135957 13365840541909761558 15132626710360857720 7340507774942928767 1592913228766078908 13606471584807705966 10250305077644017883 4423427859991722522 17723649430940885846 16583080531212839461 84625348770499352 16807952791759356559 6617722655640759049 9135334039821059708 16505768376549877469 17874867669214007061 16699545654545788279 9532320386480528388 2607353342030129577 11300198053561790958 10111831878880614237 1769233306485334138 6263025804159607663 18005808381583079203 10242005106370175322 5138829258521552303 4535725279156783705 15998214446053587665 18329741359276666964 13940851456877050262 5228185289733632635 10016003782550345445 5333604436908956668 12774602902768122642 9191004509283870122 11175903787506028644 3116226344295902832 3491691098733094205 100 0 4294967295 0.00000000000000000e+00 1.00000000000000000e+00 endrandom-v2 ";
  ASSERT_EQ(expectedString, x) << "De/serialization";

  // deserialize into r2
  std::string s(ostream.str(), ostream.pcount());
  std::stringstream ss(s);
  Random r2;
  ss >> r2;

  // r1 and r2 should be identical
  ASSERT_EQ(r1, r2) << "load from serialization";

  UInt32 v1, v2;
  for (int i = 0; i < 100; i++) {
    v1 = r1.getUInt32();
    v2 = r2.getUInt32();
    ASSERT_EQ(v1, v2) << "serialization";
  }
}


TEST(RandomTest, ReturnInCorrectRange) {
  // make sure that we are returning values in the correct range
  // @todo perform statistical tests
  Random r;
  UInt32 seed = r.getSeed();
  ASSERT_TRUE(seed != 0) << "seed not zero";
  int i;
  UInt32 max32 = 10000000;
  for (i = 0; i < 2000; i++) {
    UInt32 i32 = r.getUInt32(max32);
    ASSERT_TRUE(i32 < max32) << "UInt32";
    Real64 r64 = r.getReal64();
    ASSERT_TRUE(r64 >= 0.0 && r64 < 1.0) << "Real64";
  }
}

/*
TEST(RandomTest, getUInt64) {
  // tests for getUInt64
  Random r1(1);
  ASSERT_EQ(2469588189546311528u, r1.getUInt64())
      << "check getUInt64, seed 1, first call";
  ASSERT_EQ(2516265689700432462u, r1.getUInt64())
      << "check getUInt64, seed 1, second call";

  Random r2(2);
  ASSERT_EQ(16668552215174154828u, r2.getUInt64())
      << "check getUInt64, seed 2, first call";
  EXPECT_EQ(15684088468973760345u, r2.getUInt64())
      << "check getUInt64, seed 2, second call";

  Random r3(7464235991977222558);
  EXPECT_EQ(8035066300482877360u, r3.getUInt64())
      << "check getUInt64, big seed, first call";
  EXPECT_EQ(623784303608610892u, r3.getUInt64())
      << "check getUInt64, big seed, second call";
}
*/

TEST(RandomTest, getUInt32) {
  // tests for getUInt32
  Random r1(1);
  EXPECT_EQ(574995807, r1.getUInt32())
      << "check getUInt64, seed 1, first call";
  EXPECT_EQ(585863760, r1.getUInt32())
      << "check getUInt64, seed 1, second call";

  Random r2(2);
  EXPECT_EQ(3880949741, r2.getUInt32())
      << "check getUInt64, seed 2, first call";
  EXPECT_EQ(3651736414, r2.getUInt32())
      << "check getUInt64, seed 2, second call";

  Random r3(7464235991977222558);
  EXPECT_EQ(1870809658, r3.getUInt32())
      << "check getUInt64, big seed, first call";
  EXPECT_EQ(145236100, r3.getUInt32())
      << "check getUInt64, big seed, second call";
}


TEST(RandomTest, getReal64) {
  // tests for getReal64
  Random r1(1);
  EXPECT_DOUBLE_EQ(0.13387664401253274, r1.getReal64());
  EXPECT_DOUBLE_EQ(0.13640703636619725, r1.getReal64());

  Random r2(2);
  EXPECT_DOUBLE_EQ(0.90360402619399427, r2.getReal64());
  EXPECT_DOUBLE_EQ(0.85023613957581001, r2.getReal64());

  Random r3(7464235991977222558);
  EXPECT_DOUBLE_EQ(0.43558181695243003, r3.getReal64());
  EXPECT_DOUBLE_EQ(0.033815414856740673, r3.getReal64());
}


TEST(RandomTest, Sampling) {
  // tests for sampling

  const vector<UInt> population = {1u, 2u, 3u, 4u};
  Random r(1);

  {
    // choose some elements
    auto  choices = r.sample<UInt>(population, 2);
    ASSERT_EQ(3u, choices[0]) << "check sample 0";
    ASSERT_EQ(4u, choices[1]) << "check sample 1";
  }

  {
    // choose all elements
    vector<UInt> choices;
    ASSERT_NO_THROW(choices = r.sample<UInt>(population, 4));

    ASSERT_EQ(4u, choices[0]) << "check sample 0";
    EXPECT_EQ(1u, choices[1]) << "check sample 1";
    EXPECT_EQ(2u, choices[2]) << "check sample 2";
    EXPECT_EQ(3u, choices[3]) << "check sample 3";
  }

  //check population list remained unmodified
  ASSERT_EQ(1, population[0]) << "check sample p 0";
  ASSERT_EQ(2, population[1]) << "check sample p 1";
  ASSERT_EQ(3, population[2]) << "check sample p 2";
  ASSERT_EQ(4, population[3]) << "check sample p 3";

  {
    // nChoices > nPopulation
    EXPECT_THROW(r.sample<UInt>(population, 5), LoggingException) << "checking for exception from population too small";
  }
}


TEST(RandomTest, Shuffling) {
  // tests for shuffling
  Random r(1);
  UInt32 arr[] = {1u, 2u, 3u, 4u};
  const UInt32 exp[] = {3u, 4u, 2u, 1u};

  ASSERT_NO_THROW(r.shuffle(std::begin(arr), std::end(arr)));

  EXPECT_EQ(exp[0], arr[0]) << "check shuffle 0";
  EXPECT_EQ(exp[1], arr[1]) << "check shuffle 1";
  EXPECT_EQ(exp[2], arr[2]) << "check shuffle 2";
  EXPECT_EQ(exp[3], arr[3]) << "check shuffle 3";
}


/**
 * Test operator '=='
 */
TEST(RandomTest, testEqualsOperator) {
  Random r1(42), r2(42), r3(3);
  ASSERT_EQ(r1, r2);
  ASSERT_NE(r1, r3);
  ASSERT_NE(r2, r3);

  UInt32 v1, v2;
  v1 = r1.getUInt32();
  ASSERT_NE(r1, r2) << "one step diff";
  v2 = r2.getUInt32();
  ASSERT_EQ(r1, r2) << "synchronized steps";
  ASSERT_EQ(v1, v2);
}


TEST(RandomTest, testGetUIntSpeed) {
 Random r1(42);
 UInt32 rnd;
 const int RUNS = 10000000;
 for(int i=0; i<RUNS; i++) {
   rnd = r1.getUInt32(10000); //get random int [0..1M)
   NTA_CHECK(rnd < 1000001u) << "Should never happen, just here so compiler won't optimize out this loop";
 }
}
